drop policy "fetch_profiles" on "public"."profiles";

create table "public"."animes" (
    "id" bigint generated by default as identity not null,
    "title" text not null,
    "status" integer not null default 0,
    "season_name" text,
    "images" text,
    "no_episodes" boolean,
    "episodes_count" bigint,
    "twitter_username" text,
    "twitter_hashtag" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."animes" enable row level security;

alter table "public"."profiles" alter column "username" set not null;

CREATE UNIQUE INDEX animes_pkey ON public.animes USING btree (id);

CREATE UNIQUE INDEX animes_title_key ON public.animes USING btree (title);

alter table "public"."animes" add constraint "animes_pkey" PRIMARY KEY using index "animes_pkey";

alter table "public"."animes" add constraint "animes_title_key" UNIQUE using index "animes_title_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
  declare
    claims jsonb;
    is_admin boolean;
    username text;
    user_id_value uuid;
  begin
    -- RAISE LOG 'even valu user_id-----: %', (event->>'user_id')::uuid; -- is_adminの値をログとして出力
    -- Check if the user is marked as admin in the profiles table
    select profiles.is_admin into is_admin from public.profiles where user_id = (event->>'user_id')::uuid;
    RAISE LOG 'is_admin value: (%)', is_admin;

    user_id_value := (event->>'user_id')::uuid;
    select profiles.username into username from public.profiles limit 1;
    
    RAISE LOG 'user_id value: (%)', user_id_value;
    RAISE LOG 'username value: (%)', username;


    -- Proceed only if the user is an admin
    if is_admin then
      claims := event->'claims';

      -- Check if 'app_metadata' exists in claims
      if jsonb_typeof(claims->'app_metadata') is null then
        -- If 'app_metadata' does not exist, create an empty object
        claims := jsonb_set(claims, '{app_metadata}', '{}');
      end if;

      -- Set a claim of 'admin'
      claims := jsonb_set(claims, '{app_metadata, admin}', 'true');

      -- Update the 'claims' object in the original event
      event := jsonb_set(event, '{claims}', claims);
    end if;

    -- Return the modified or original event
    return event;
  end;
$function$
;

grant delete on table "public"."animes" to "anon";

grant insert on table "public"."animes" to "anon";

grant references on table "public"."animes" to "anon";

grant select on table "public"."animes" to "anon";

grant trigger on table "public"."animes" to "anon";

grant truncate on table "public"."animes" to "anon";

grant update on table "public"."animes" to "anon";

grant delete on table "public"."animes" to "authenticated";

grant insert on table "public"."animes" to "authenticated";

grant references on table "public"."animes" to "authenticated";

grant select on table "public"."animes" to "authenticated";

grant trigger on table "public"."animes" to "authenticated";

grant truncate on table "public"."animes" to "authenticated";

grant update on table "public"."animes" to "authenticated";

grant delete on table "public"."animes" to "service_role";

grant insert on table "public"."animes" to "service_role";

grant references on table "public"."animes" to "service_role";

grant select on table "public"."animes" to "service_role";

grant trigger on table "public"."animes" to "service_role";

grant truncate on table "public"."animes" to "service_role";

grant update on table "public"."animes" to "service_role";

create policy "Fetch animes for users"
on "public"."animes"
as permissive
for select
to authenticated
using (true);


create policy "animes admin users"
on "public"."animes"
as permissive
for all
to authenticated
using (((((auth.jwt() -> 'app_metadata'::text) ->> 'admin'::text))::boolean = true));


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for all
to supabase_auth_admin
using (true);


create policy "profiles admin users"
on "public"."profiles"
as permissive
for all
to authenticated
using (((((auth.jwt() -> 'app_metadata'::text) ->> 'admin'::text))::boolean = true));


create policy "fetch_profiles"
on "public"."profiles"
as permissive
for select
to authenticated, supabase_auth_admin
using ((auth.uid() = user_id));



